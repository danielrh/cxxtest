cxxtest_path = '../..'

env = Environment()

# First build the 'real' library that will be tested.
env.Append(CPPPATH=['include'])
libtested = env.StaticLibrary('tested', env.Glob('src/*.c'))

# Now create a seperate build environment for the tests so we can keep any
# options that are specific to testing  seperate from the 'production' build
# environment. For simplicity I am just copying the production environment.
env_test = env.Copy()

# In some circumstances you may want to bulid a testing version of the 'real'
# library here. This may be necesary if you are using any link-time or compile
# time seams (such as preprocessor magic). ... e.g.
# env_test.Append(CPPDEFINES=[ ('TESTING,1), ] )
# libtested_test = env_test.StaticLibrary('tested_test', env.Glob('src/*.c'))

# Add cxxtest to the include path
env_test.Append(CPPPATH=[cxxtest_path, '.'])
# And add the library to the link
env_test.Append(LIBS=[libtested])

# Now lets find all the test code, and feed it to cxxtestgen.py
test_headers = env_test.Glob('tests/*.h')

# If you were building several different test programs you may want to
# generalize things below by adding build environment variables for the
# options to cxxtestgen.py.
testsrc = env_test.Command('cxxtestmain.cpp', test_headers,
  'python %s/cxxtestgen.py --error-printer -o $TARGET $SOURCES'%cxxtest_path)
testprog = env_test.Program('testrunner', testsrc)

# In order to get SCons to actually run this it needs a target to be built.
# Since I am redirecting the output, you will not see when the build is 
# happening. But, if any test fails, the build will report a failure, and
# you can examine testresults.txt for more details.
testresults = env_test.Command('testresults.txt', testprog,
                './$SOURCE > $TARGET')
env_test.AlwaysBuild(testresults)

